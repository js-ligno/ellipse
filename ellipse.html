<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ellipse Draw & Edit (Vanilla JS)</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #myCanvas {
      background-color: #fafafa;
      border: 1px solid #ccc;
      cursor: crosshair;
    }
  </style>
</head>
<body>
<canvas id="myCanvas" width="1200" height="800"></canvas>

<script>
// -----------------------------------------------------------
// Utility functions for transformations
// -----------------------------------------------------------

/**
 * Rotate a point (x, y) about the origin (0, 0) by `angle` radians.
 */
function rotatePoint(x, y, angle) {
  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);
  const rx = x * cosA - y * sinA;
  const ry = x * sinA + y * cosA;
  return [rx, ry];
}

/**
 * Shear a point (x, y) by shearX along x-direction or shearY along y-direction.
 * We combine them here so we can apply both at once if needed.
 * Shear matrix:
 *   [1   shearX]
 *   [shearY  1 ]
 */
function shearPoint(x, y, shearX, shearY) {
  const sx = x + shearX * y;
  const sy = y + shearY * x;
  return [sx, sy];
}

/**
 * Return an array of points approximating an ellipse, applying rotation & shear.
 * We do a parametric approach from 0..2Ï€ in small steps.
 * 
 * ellipseData = {
 *   centerX, centerY,
 *   radiusX, radiusY,
 *   rotation,     // rotation in radians
 *   shearX, shearY
 * }
 */
function getEllipsePoints(ellipseData, steps = 50) {
  const {
    centerX, centerY,
    radiusX, radiusY,
    rotation,
    shearX, shearY
  } = ellipseData;

  const points = [];
  for (let i = 0; i <= steps; i++) {
    const t = (Math.PI * 2 * i) / steps;
    // Parametric ellipse (no transform yet)
    let x = radiusX * Math.cos(t);
    let y = radiusY * Math.sin(t);

    // Apply shear first (in local space)
    [x, y] = shearPoint(x, y, shearX, shearY);

    // Apply rotation
    [x, y] = rotatePoint(x, y, rotation);

    // Finally translate to the ellipse center
    x += centerX;
    y += centerY;

    points.push({ x, y });
  }
  return points;
}

/**
 * Helper to find the bounding box for the transformed ellipse:
 * We evaluate all parametric points, find min/max.
 */
function getEllipseBoundingBox(ellipseData) {
  const pts = getEllipsePoints(ellipseData, 50);
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  pts.forEach(pt => {
    if (pt.x < minX) minX = pt.x;
    if (pt.x > maxX) maxX = pt.x;
    if (pt.y < minY) minY = pt.y;
    if (pt.y > maxY) maxY = pt.y;
  });

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}

/**
 * Check if a point (mx, my) is inside ellipse bounding box
 */
function isPointInBox(mx, my, box) {
  return (
    mx >= box.x &&
    mx <= box.x + box.width &&
    my >= box.y &&
    my <= box.y + box.height
  );
}

/**
 * Check if a point (mx, my) is inside the ellipse itself
 * We'll do a point-in-polygon approach by summing angles or using raycasting,
 * but a simpler approximate check is to invert the transformations and see if the
 * resulting local (x', y') satisfies x'^2/rx'^2 + y'^2/ry'^2 <= 1
 * We invert rotation and shear to get back to local space, then check standard ellipse eqn.
 *
 * For brevity, let's do an approximate approach: we sample ellipse boundary,
 * see if distance to boundary is minimal, or do the direct local transform approach.
 */
function isPointInEllipse(mx, my, ellipseData) {
  const {
    centerX, centerY,
    radiusX, radiusY,
    rotation, shearX, shearY
  } = ellipseData;

  // Translate point to ellipse-centered coordinate
  let lx = mx - centerX;
  let ly = my - centerY;

  // Invert rotation: rotate by -rotation
  [lx, ly] = rotatePoint(lx, ly, -rotation);

  // Invert shear. The matrix we used is [1 shearX; shearY 1].
  // We need the inverse of that matrix, which is
  // (1 / (1 - shearX*shearY)) * [1   -shearX; -shearY   1].
  const det = 1 - shearX * shearY;
  if (Math.abs(det) < 1e-10) {
    // Degenerate shear?  Just skip for now
    return false;
  }
  const inv00 =  1 / det;
  const inv01 = -shearX / det;
  const inv10 = -shearY / det;
  const inv11 =  1 / det;

  const lxTemp = lx * inv00 + ly * inv01;
  const lyTemp = lx * inv10 + ly * inv11;
  lx = lxTemp;
  ly = lyTemp;

  // Now check if in standard ellipse range
  const val = (lx * lx) / (radiusX * radiusX) + (ly * ly) / (radiusY * radiusY);
  return val <= 1;
}

/**
 * Compute the 8 handle positions from the bounding box (corners + mid-sides).
 */
function getHandlesFromBox(box) {
  const { x, y, width, height } = box;
  const midX = x + width / 2;
  const midY = y + height / 2;

  return [
    // corners
    { x: x,         y: y,          role: 'top-left'     },
    { x: x + width, y: y,          role: 'top-right'    },
    { x: x,         y: y + height, role: 'bottom-left'  },
    { x: x + width, y: y + height, role: 'bottom-right' },

    // mid-sides
    { x: midX,      y: y,          role: 'top-middle'   },
    { x: midX,      y: y + height, role: 'bottom-middle'},
    { x: x,         y: midY,       role: 'left-middle'  },
    { x: x + width, y: midY,       role: 'right-middle' },
  ];
}


/**
 * Check if mouse is near a handle (simple distance check).
 */
function findHandleHit(handles, mx, my, radius = 6) {
  for (let i = 0; i < handles.length; i++) {
    const hx = handles[i].x;
    const hy = handles[i].y;
    const dx = mx - hx;
    const dy = my - hy;
    if (dx * dx + dy * dy <= radius * radius) {
      return handles[i];
    }
  }
  return null;
}

// -----------------------------------------------------------
// Main application
// -----------------------------------------------------------

const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

let isDrawing = false;          // for initial 2-click ellipse creation
let ellipseData = {
  centerX: 0,
  centerY: 0,
  radiusX: 0,
  radiusY: 0,
  rotation: 0,
  shearX: 0,
  shearY: 0
};
let hasEllipse = false;         // becomes true after 2nd click

let showBoundingBox = false;
let editMode = 'resize-shear';  // can be 'resize-shear' or 'rotate'
let isDragging = false;
let dragHandle = null;
let lastMousePos = { x: 0, y: 0 };

// Mouse events
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('mouseup', onMouseUp);
// For toggling bounding box via right-click:
canvas.addEventListener('contextmenu', onContextMenu);

function onMouseDown(e) {
  const { offsetX: mx, offsetY: my, button } = e;
  lastMousePos = { x: mx, y: my };

  // If right-click, we handle that in onContextMenu.
  if (button === 2) return;

  if (!hasEllipse) {
    // We are in the process of creating ellipse with 2 clicks.
    if (!isDrawing) {
      // First click => set center
      ellipseData.centerX = mx;
      ellipseData.centerY = my;
      ellipseData.radiusX = 0;
      ellipseData.radiusY = 0;
      isDrawing = true;
    } else {
      // Second click => finalize ellipse creation
      // If radiusX & radiusY are zero because user clicked same point, set some default
      if (ellipseData.radiusX === 0 && ellipseData.radiusY === 0) {
        ellipseData.radiusX = 10;
        ellipseData.radiusY = 10;
      }
      isDrawing = false;
      hasEllipse = true;
      showBoundingBox = true;
    }
  } else {
    // We have an ellipse. Check if bounding box is visible
    if (showBoundingBox) {
      // 1) Check if user clicked on a handle
      const box = getEllipseBoundingBox(ellipseData);
      const handles = getHandlesFromBox(box);
      const hitHandle = findHandleHit(handles, mx, my);
      if (hitHandle) {
        // Start dragging a handle
        isDragging = true;
        dragHandle = hitHandle;
        return;
      }

      // 2) Check if user clicked inside bounding box but not on handle
      if (isPointInBox(mx, my, box)) {
        // Toggle edit mode if not dragging
        // That is "each next click inside box changes mode rotate <-> resize-shear"
        // But let's only toggle if we're not in the middle of a handle drag.
        editMode = (editMode === 'resize-shear') ? 'rotate' : 'resize-shear';
        drawAll();
        return;
      }

      // 3) If user clicked outside the bounding box, see if it's inside the ellipse
      if (isPointInEllipse(mx, my, ellipseData)) {
        // Then we show bounding box again or do nothing, depending on your logic
        // But we already have bounding box shown. So do nothing special here.
      } else {
        // Clicked outside ellipse => do nothing or close bounding box?
        // Not specified to do anything special. We'll do nothing.
      }
    } else {
      // bounding box is NOT shown
      // "Click inside ellipse w/o bounding rectangle should return edit mode"
      // => check if we clicked in ellipse
      if (isPointInEllipse(mx, my, ellipseData)) {
        showBoundingBox = true;
        editMode = 'resize-shear'; // default
      }
    }
  }

  drawAll();
}

function onMouseMove(e) {
  const { offsetX: mx, offsetY: my } = e;

  if (!hasEllipse && isDrawing) {
    // We're creating an ellipse in real time
    // The center is ellipseData.centerX,centerY; 
    // Radius is the distance to current mouse
    ellipseData.radiusX = Math.abs(mx - ellipseData.centerX);
    ellipseData.radiusY = Math.abs(my - ellipseData.centerY);
    drawAll();
    return;
  }

  if (hasEllipse && isDragging && dragHandle) {
    // We are resizing/shearing/rotating the ellipse depending on the handle and editMode
    const dx = mx - lastMousePos.x;
    const dy = my - lastMousePos.y;

    // If we are in 'resize-shear' mode:
    if (editMode === 'resize-shear') {
      if (dragHandle.role.includes('middle')) {
        // Shear
        if (dragHandle.role === 'top-middle' || dragHandle.role === 'bottom-middle') {
          // Shear in X direction
          // For simplicity: small factor from dx or dy
          // Typically you'd track the sign of dy to decide how to shear
          ellipseData.shearX += dy * 0.01; 
        } else if (dragHandle.role === 'left-middle' || dragHandle.role === 'right-middle') {
          // Shear in Y direction
          ellipseData.shearY += dx * 0.01;
        }
      } else {
        // Corners => resizing
        // We'll do a simple approach: the change in dx, dy => adjust radius
        // The "top-left" handle might reduce radiusX and radiusY etc. We do a naive approach
        const signX = (dragHandle.role.includes('left')) ? -1 : 1;
        const signY = (dragHandle.role.includes('top')) ? -1 : 1;
        ellipseData.radiusX += signX * dx;
        ellipseData.radiusY += signY * dy;
        // Ensure radius is not negative or extremely small
        ellipseData.radiusX = Math.max(5, ellipseData.radiusX);
        ellipseData.radiusY = Math.max(5, ellipseData.radiusY);
      }
    } 
    else if (editMode === 'rotate') {
      // Rotate ellipse
      // We'll do a naive approach: angle depends on dx, for example.
      ellipseData.rotation += dx * 0.01;
    }

    lastMousePos.x = mx;
    lastMousePos.y = my;
    drawAll();
  }
}

function onMouseUp(e) {
  isDragging = false;
  dragHandle = null;
}

function onContextMenu(e) {
  // Right-click
  e.preventDefault();
  // "Right click should remove the surrounding rectangle (but ellipse remains)"
  showBoundingBox = false;
  drawAll();
}

// -----------------------------------------------------------
// Main drawing
// -----------------------------------------------------------
function drawAll() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // If we're drawing ellipse
  if (!hasEllipse && isDrawing) {
    // Just show the in-progress ellipse
    drawEllipse(ellipseData);
    return;
  }

  // If ellipse exists, draw it
  if (hasEllipse) {
    drawEllipse(ellipseData);
  }

  // If bounding box is shown, draw it + handles
  if (hasEllipse && showBoundingBox) {
    const box = getEllipseBoundingBox(ellipseData);
    drawBoundingBox(box);

    // Draw handles
    const handles = getHandlesFromBox(box);
    drawHandles(handles);
  }
}

/**
 * Draw ellipse using the parametric points
 */
function drawEllipse(ellipseData) {
  const pts = getEllipsePoints(ellipseData, 60);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(pts[i].x, pts[i].y);
  }
  ctx.closePath();
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();
}

/**
 * Draw bounding box (simple rectangle)
 */
function drawBoundingBox(box) {
  ctx.save();
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 1;
  ctx.strokeRect(box.x, box.y, box.width, box.height);
  ctx.restore();
}

/**
 * Draw the 8 handles. 
 * If editMode = 'rotate', handles become half-circles as an example
 */
function drawHandles(handles) {
  ctx.save();
  ctx.fillStyle = 'red';
  ctx.strokeStyle = 'red';

  handles.forEach(h => {
    ctx.beginPath();
    if (editMode === 'rotate') {
      // half-circle (just for demonstration, let's do a top half arc):
      ctx.arc(h.x, h.y, 5, 0, Math.PI, false); // half circle
      ctx.stroke();
    } else {
      // full circle
      ctx.arc(h.x, h.y, 5, 0, Math.PI * 2, false);
      ctx.fill();
    }
  });

  ctx.restore();
}

// Initial render
drawAll();
</script>
</body>
</html>
